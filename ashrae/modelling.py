# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/one_meter_one_model.ipynb (unless otherwise specified).

__all__ = ['evaluate_torch', 'cnr', 'get_embedding_features_df', 'replace_cat_features_with_embeddings', 'pick_random',
           'evaluate_torch', 'cnr', 'Swish', 'Sine', 'pick_random', 'evaluate_torch', 'cnr', 'Swish', 'Sine',
           'pick_random']

# Cell
from ashrae import loading, preprocessing, feature_testing

import pandas as pd
from pathlib import Path
import os
import plotly.graph_objects as go
import plotly.express as px
import numpy as np
import typing
import pickle


from sklearn import linear_model, tree, model_selection, ensemble

from fastai.tabular.all import *

import lightgbm as lgb

import ipywidgets as widgets

# Cell
def evaluate_torch(y_true:torch.Tensor, y_pred:torch.Tensor): return torch.sqrt(F.mse_loss(y_true, y_pred))

# Cell
cnr = lambda x: x.clone().numpy().ravel() # clone numpy ravel

# Cell
def get_embedding_features_df(col:str, to:TabularPandas, learn:Learner):
    ix = to.cat_names.index(col)
    w_emb = learn.model.embeds[ix].weight.detach().clone().numpy()
    df_emb = (pd.DataFrame(w_emb)
              .add_prefix(f'{col}_embedding_'))
    df_emb.index.rename(col, inplace=True)
    return df_emb

# Cell
def replace_cat_features_with_embeddings(X:pd.DataFrame, to:TabularPandas, learn:Learner):
    for col in to.cat_names:
        df_emb = get_embedding_features_df(col, to, learn)
        X = X.join(df_emb, on=col, how='left').drop(columns=col)
    return X

# Cell
pick_random = lambda x: np.random.choice(x, size=5000, replace=False)

# Cell
from ashrae import loading, preprocessing, feature_testing

import pandas as pd
from pathlib import Path
import os
import plotly.graph_objects as go
import plotly.express as px
import numpy as np
import typing
import pickle


from sklearn import linear_model, tree, model_selection, ensemble

from fastai.tabular.all import *

import lightgbm as lgb

import ipywidgets as widgets

# Cell
def evaluate_torch(y_true:torch.Tensor, y_pred:torch.Tensor): return torch.sqrt(F.mse_loss(y_true, y_pred))

# Cell
cnr = lambda x: x.clone().numpy().ravel() # clone numpy ravel

# Cell
class Swish(nn.ReLU):
    def forward(self, input:Tensor) -> Tensor:
        if self.inplace:
            res = input.clone()
            torch.sigmoid_(res)
            input *= res
            return input
        else:
            return torch.sigmoid(input) * input

class Sine(nn.ReLU):
    def forward(self, input:Tensor) -> Tensor:
        if self.inplace:
            return torch.sin_(input)
        else:
            return torch.sin(input)

# Cell
pick_random = lambda x: np.random.choice(x, size=5000, replace=False)

# Cell
from ashrae import preprocessing

import pandas as pd
from pathlib import Path
import os
import plotly.graph_objects as go
import plotly.express as px
import numpy as np
import typing
import pickle


from sklearn import linear_model, tree, model_selection, ensemble

from fastai.tabular.all import *

import lightgbm as lgb

import ipywidgets as widgets

# Cell
def evaluate_torch(y_true:torch.Tensor, y_pred:torch.Tensor): return torch.sqrt(F.mse_loss(y_true, y_pred))

# Cell
cnr = lambda x: x.clone().numpy().ravel() # clone numpy ravel

# Cell
class Swish(nn.ReLU):
    def forward(self, input:Tensor) -> Tensor:
        if self.inplace:
            res = input.clone()
            torch.sigmoid_(res)
            input *= res
            return input
        else:
            return torch.sigmoid(input) * input

class Sine(nn.ReLU):
    def forward(self, input:Tensor) -> Tensor:
        if self.inplace:
            return torch.sin_(input)
        else:
            return torch.sin(input)

# Cell
pick_random = lambda x: np.random.choice(x, size=5000, replace=False)