# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_inspection.ipynb (unless otherwise specified).

__all__ = ['get_csvs', 'CSV_NAMES', 'get_core_Xy', 'show_nans', 'get_building_X', 'get_weather_X', 'InspectTimeseries']

# Cell
import pandas as pd
from pathlib import Path
from fastcore.utils import *
import os
import plotly.graph_objects as go
import plotly.express as px
import numpy as np
import typing

from fastai.tabular.all import *

import matplotlib.pyplot as plt

import ipywidgets as widgets

# Cell
CSV_NAMES = ['building', 'sample_submission', 'test', 'train', 'weather_test', 'weather_train']

def get_csvs(data_path:Path, csv_names:typing.List[str]=None) -> typing.Dict[str, Path]:
    csvs = sorted([v for v in data_path.ls() if v.name.endswith('.csv')])
    csv_names = CSV_NAMES if csv_names is None else csv_names
    return {_name: [_csv for _csv in csvs if _csv.name.startswith(_name)][0]
            for _name in csv_names}

# Cell
def get_core_Xy(path:Path, nrows:int=None) -> pd.DataFrame:
    df = pd.read_csv(path, parse_dates=['timestamp'], nrows=nrows)
    return df_shrink(df, int2uint=True)

# Cell
def show_nans(df:pd.DataFrame):
    nans = []
    for col in df.columns:
        nans.append({
            'nans count': df[col].isna().sum(),
            'col':col,
            'nans %': df[col].isna().sum() / len(df) * 100,
        })
    return pd.DataFrame(nans).sort_values('nans count', ascending=False)

# Cell
def get_building_X(path:Path):
    # TODO: year_built and floor_count actually are discrete values but contain nans
    # test if 'Int' dtype would work or if it breaks the things downstream
    df_building = pd.read_csv(path)
    return df_shrink(df_building, int2uint=True)

# Cell
def get_weather_X(path:Path):
    # TODO: cloud_coverage, wind_direction could be Int
    df = pd.read_csv(path, parse_dates=['timestamp'])
    return df

# Cell
class InspectTimeseries:
    def __init__(self, train:pd.DataFrame, building:pd.DataFrame=None,
                 weather:pd.DataFrame=None):

        self.df = train
        self.building = building
        self.weather = weather
        self.combos = list(zip(*train.loc[:,['building_id', 'meter']]
                       .drop_duplicates()
                       .values.T))


# Cell
@patch
def init_widgets(self:InspectTimeseries):

    self.int_txt_meter = widgets.IntText(min=self.df['meter'].min(),
                                         max=self.df['meter'].max(),
                                         description='Meter')
    self.int_txt_bid = widgets.IntText(min=self.df['building_id'].min(),
                                       max=self.df['building_id'].max(),
                                       description='building id')

    self.run_btn = widgets.Button(description='plot')
    self.run_btn.on_click(self.click_boldly)
    self.out_wdg = widgets.Output()


@patch
def inspect_boldly(self:InspectTimeseries):
    if not hasattr(self, 'switch_btn'):
        self.init_widgets()
    return widgets.VBox([self.int_txt_meter,
                         self.int_txt_bid,
                         self.run_btn, self.out_wdg])

@patch
def click_boldly(self:InspectTimeseries, change):
    self.out_wdg.clear_output()
    meter = self.int_txt_meter.value
    bid = self.int_txt_bid.value

    with self.out_wdg:
        print(f'Selected: meter {meter} bid {bid}')
        if (bid, meter) not in self.combos:
            print('Combination not in the training set ðŸ¥´')
        else:
            self.plot_boldly(meter=meter, bid=bid).show()

# Cell
@patch
def plot_boldly(self:InspectTimeseries,
                meter:int=None, bid:int=None):

    dep_var = 'meter_reading'
    assert (meter is not None and bid is not None)

    mask = (self.df['meter']==int(meter)) & (self.df['building_id']==int(bid))
    df_plot = self.df.loc[mask, ['timestamp', dep_var]]
    fig = px.scatter(df_plot, x='timestamp',
                   y=dep_var,
                   title=f'meter = {meter}, building_id = {bid}')
#     fig.update_traces(line=dict(color="Black", width=.4))
    fig.update_traces(marker=dict(size=1.5,color='Black'))
    return fig
